// This is your Prisma schema file for Pharmacy POS SaaS
// Multi-tenant architecture with Store as the tenant

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum SubscriptionPlan {
  TRIAL
  BASIC
  STANDARD
  ADVANCED
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  SUSPENDED
}

enum UserRole {
  OWNER
  ADMIN
  MANAGER
  PHARMACIST
  CASHIER
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum ProductCategory {
  MEDICINE
  SUPPLEMENT
  COSMETIC
  MEDICAL_EQUIPMENT
  PERSONAL_CARE
  BABY_CARE
  OTHER
}

enum BillStatus {
  PENDING
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CARD
  UPI
  BANK_TRANSFER
  OTHER
}

enum NotificationType {
  INFO
  WARNING
  ALERT
  SUCCESS
  EXPIRY
  LOW_STOCK
  SUBSCRIPTION
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

// ============================================
// MODELS
// ============================================

/// Store represents a pharmacy (tenant) in the multi-tenant system
model Store {
  id                String    @id @default(uuid()) @db.Uuid
  name              String
  slug              String    @unique
  email             String    @unique
  phone             String?
  address           String?
  city              String?
  state             String?
  postalCode        String?
  country           String    @default("India")
  logo              String?
  licenseNumber     String?
  gstNumber         String?
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  users             User[]
  subscriptions     Subscription[]
  products          Product[]
  customers         Customer[]
  bills             Bill[]
  notifications     Notification[]

  @@index([email])
  @@index([slug])
  @@map("stores")
}

/// User belongs to a Store and has role-based access
model User {
  id                String      @id @default(uuid()) @db.Uuid
  email             String
  password          String
  firstName         String
  lastName          String?
  phone             String?
  avatar            String?
  role              UserRole    @default(CASHIER)
  status            UserStatus  @default(ACTIVE)
  emailVerified     Boolean     @default(false)
  lastLoginAt       DateTime?
  
  // Email verification tokens
  verificationToken       String?
  verificationTokenExpiry DateTime?
  
  // Password reset tokens
  resetPasswordToken      String?
  resetPasswordExpiry     DateTime?
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Multi-tenant relation
  storeId           String      @db.Uuid
  store             Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Relations
  bills             Bill[]
  notifications     Notification[]

  @@unique([email, storeId])
  @@index([storeId])
  @@index([email])
  @@index([role])
  @@index([verificationToken])
  @@index([resetPasswordToken])
  @@map("users")
}

/// Subscription tracks the store's plan and billing cycle
model Subscription {
  id                String             @id @default(uuid()) @db.Uuid
  plan              SubscriptionPlan   @default(TRIAL)
  status            SubscriptionStatus @default(ACTIVE)
  startDate         DateTime           @default(now())
  endDate           DateTime
  trialEndsAt       DateTime?
  billingCycleStart DateTime?
  billingCycleEnd   DateTime?
  amount            Decimal            @default(0) @db.Decimal(10, 2)
  currency          String             @default("INR")
  autoRenew         Boolean            @default(true)
  paymentId         String?
  invoiceId         String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // Multi-tenant relation
  storeId           String             @db.Uuid
  store             Store              @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([status])
  @@index([endDate])
  @@map("subscriptions")
}

/// Product represents items sold in the pharmacy
model Product {
  id                String          @id @default(uuid()) @db.Uuid
  name              String
  genericName       String?
  sku               String
  barcode           String?
  category          ProductCategory @default(MEDICINE)
  manufacturer      String?
  supplier          String?
  description       String?
  
  // Pricing
  costPrice         Decimal         @db.Decimal(10, 2)
  sellingPrice      Decimal         @db.Decimal(10, 2)
  mrp               Decimal         @db.Decimal(10, 2)
  taxPercent        Decimal         @default(0) @db.Decimal(5, 2)
  discountPercent   Decimal         @default(0) @db.Decimal(5, 2)
  
  // Inventory
  quantity          Int             @default(0)
  minStockLevel     Int             @default(10)
  maxStockLevel     Int             @default(1000)
  reorderLevel      Int             @default(20)
  unit              String          @default("pcs")
  
  // Pharmacy specific
  batchNumber       String?
  expiryDate        DateTime?
  manufacturingDate DateTime?
  requiresPrescription Boolean      @default(false)
  scheduleType      String?         // H, H1, X, etc.
  storageConditions String?
  
  // Category specific
  tabletsPerStrip   Int?
  qtyInMl           Decimal?        @db.Decimal(10, 2)
  composition       String?
  
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Multi-tenant relation
  storeId           String          @db.Uuid
  store             Store           @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Relations
  billItems         BillItem[]

  @@unique([sku, storeId])
  @@unique([barcode, storeId])
  @@index([storeId])
  @@index([name])
  @@index([category])
  @@index([expiryDate])
  @@map("products")
}

/// Customer represents buyers at the pharmacy
model Customer {
  id                String    @id @default(uuid()) @db.Uuid
  firstName         String
  lastName          String?
  email             String?
  phone             String
  address           String?
  city              String?
  state             String?
  postalCode        String?
  dateOfBirth       DateTime?
  gender            String?
  
  // Loyalty
  loyaltyPoints     Int       @default(0)
  totalPurchases    Decimal   @default(0) @db.Decimal(12, 2)
  
  // Medical info (optional)
  allergies         String?
  chronicConditions String?
  notes             String?
  
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Multi-tenant relation
  storeId           String    @db.Uuid
  store             Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Relations
  bills             Bill[]

  @@unique([phone, storeId])
  @@index([storeId])
  @@index([phone])
  @@index([email])
  @@map("customers")
}

/// Bill represents a sales transaction
model Bill {
  id                String        @id @default(uuid()) @db.Uuid
  billNumber        String
  
  // Amounts
  subtotal          Decimal       @db.Decimal(12, 2)
  taxAmount         Decimal       @default(0) @db.Decimal(10, 2)
  discountAmount    Decimal       @default(0) @db.Decimal(10, 2)
  totalAmount       Decimal       @db.Decimal(12, 2)
  paidAmount        Decimal       @default(0) @db.Decimal(12, 2)
  changeAmount      Decimal       @default(0) @db.Decimal(10, 2)
  doctorFees        Decimal       @default(0) @db.Decimal(10, 2)
  otherCharges      Decimal       @default(0) @db.Decimal(10, 2)
  
  // Payment
  paymentMethod     PaymentMethod @default(CASH)
  paymentReference  String?
  status            BillStatus    @default(PENDING)
  
  // Prescription
  prescriptionNumber String?
  doctorName         String?
  
  notes             String?
  billedAt          DateTime      @default(now())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Multi-tenant relation
  storeId           String        @db.Uuid
  store             Store         @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Relations
  customerId        String?       @db.Uuid
  customer          Customer?     @relation(fields: [customerId], references: [id], onDelete: SetNull)
  
  userId            String        @db.Uuid
  user              User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  
  billItems         BillItem[]

  @@unique([billNumber, storeId])
  @@index([storeId])
  @@index([customerId])
  @@index([userId])
  @@index([billedAt])
  @@index([status])
  @@map("bills")
}

/// BillItem represents individual items in a bill
model BillItem {
  id                String    @id @default(uuid()) @db.Uuid
  
  // Product snapshot (in case product is deleted/modified)
  productName       String
  productSku        String
  batchNumber       String?
  expiryDate        DateTime?
  
  // Quantity and pricing
  quantity          Int
  unitPrice         Decimal   @db.Decimal(10, 2)
  costPrice         Decimal   @db.Decimal(10, 2)
  mrp               Decimal   @db.Decimal(10, 2)
  taxPercent        Decimal   @default(0) @db.Decimal(5, 2)
  taxAmount         Decimal   @default(0) @db.Decimal(10, 2)
  discountPercent   Decimal   @default(0) @db.Decimal(5, 2)
  discountAmount    Decimal   @default(0) @db.Decimal(10, 2)
  totalAmount       Decimal   @db.Decimal(12, 2)
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Multi-tenant relation
  storeId           String    @db.Uuid

  // Relations
  billId            String    @db.Uuid
  bill              Bill      @relation(fields: [billId], references: [id], onDelete: Cascade)
  
  productId         String?   @db.Uuid
  product           Product?  @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([storeId])
  @@index([billId])
  @@index([productId])
  @@map("bill_items")
}

/// Notification for alerts, reminders, and system messages
model Notification {
  id                String             @id @default(uuid()) @db.Uuid
  title             String
  message           String
  type              NotificationType   @default(INFO)
  status            NotificationStatus @default(UNREAD)
  
  // Optional link to related entity
  entityType        String?            // 'product', 'bill', 'subscription', etc.
  entityId          String?            @db.Uuid
  
  // Optional action
  actionUrl         String?
  actionLabel       String?
  
  readAt            DateTime?
  expiresAt         DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  // Multi-tenant relation
  storeId           String             @db.Uuid
  store             Store              @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Optional user relation (null means store-wide notification)
  userId            String?            @db.Uuid
  user              User?              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}
